.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Plugin::Installer 3"
.TH Plugin::Installer 3 "2005-10-30" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Plugin::Installer
.PP
Call the plugin's compiler, install it via quality_to_ref, then
dispatch it using goto.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package Myplugin;
.Ve
.PP
.Vb 1
\&    use base qw( Plugin::Installer Plugin::Language::Foobar );
.Ve
.PP
.Vb 1
\&    ...
.Ve
.PP
.Vb 1
\&    my $plugin = Myplugin->construct;
.Ve
.PP
.Vb 5
\&    # frobnicate is passed first to Plugin::Installer 
\&    # via AUTOLOAD, then to P::L::Foobar's compile
\&    # method. if what comes back from the compiler is
\&    # a referent it is intalled in the P::L::F namespace
\&    # and if it is a code referent it is dispatched.
.Ve
.PP
.Vb 1
\&    $plugin->frobnicate;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Plugin framework gives runtime compile, 
install, and dispatch of user-defined code.
The code doesn't have to be Perl, just something
that the object handling it can compile. 
.PP
The installer is language\-agnostic: in fact it
has no idea what the object does with the name
passed to its compioer. All it does is (by 
default) install a returned reference and dispatch
coderefs. This is intended as a convienence class
that standardizes the top half of any plugin 
language.
.Sh "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
Extracts the package and method name from a call,
dispatches \f(CW$package\fR\->compile( \f(CW$name\fR ), and handles
the result. Results can be installed (if they are
referents of any type) and dispatched (if they are
coderefs).
.PP
The point of this is that the pluing language is
free to compile the plugin source to whatever suits
it best, Plugin::Installer will install the result.
.PP
In most cases the result will be a coderef, which 
will be installed as \f(CW$AUTOLOAD\fR, which allows 
plugins to resolve themselves from source to method
at runtime.
.Sh "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
Stub, saves passing back through the \s-1AUTOLOAD\s0
unnecessarly. Plugin classes that need housekeeping
should implement a \s-1DESTROY\s0 of their own.
.Sh "Plugin install metadata"
.IX Subsection "Plugin install metadata"
During compilation, Plugin::Install::AUTOLOAD
places an {install_meta} entry into the object.
This is done via local hash value, and will not
be visible to the caller after the autoloader 
has processed the call.
.PP
This defines switches used for post-compile 
handling:
.PP
.Vb 5
\&    my $default_meta = 
\&    {
\&        install     => 1,
\&        dispatch    => 1,
\&        storemeta   => 0,
.Ve
.PP
.Vb 2
\&        alt_package => '',
\&    };
.Ve
.IP "install     => 1," 4
.IX Item "install     => 1,"
Does a referent returned from \f(CW$obj\fR\->compile get installed
into the namespace or simply dispatched?
.Sp
This is used to avoid installing plugins whose 
contents will be re-defined during execution
and called multiple times. 
.IP "dispatch    => 1," 4
.IX Item "dispatch    => 1,"
Is a code referent dispatched (whether or not it is 
installed into a package)?
.Sp
Some methods may be easier to pre-install but not 
dispatch immediately (e.g. if they involve expensive
startup but have per-execution side\-effects). Setting
this to false will skip dispatch of coderef's even
if they are installed.
.IP "alt_package => ''," 4
.IX Item "alt_package => '',"
Package to install the referent into (default if
false is the object's package). This the namespace
passed with the method name to 'qualify_to_ref'.
.Sp
This can be used by the compiler to install data
or coderef's into a caller's namespace (e.g. via
\&\fIcaller\fR\|(2)). If this is used with storemeta then 
\&\s-1ALL\s0 of the methods for the plugin class will be 
installed into the alternate package space unless
they set their own alt_package when called.
.IP "storemeta   => 0," 4
.IX Item "storemeta   => 0,"
Store the current metdata as the default for this
class? The metadata is stored by class name, allowing
an initial \*(L"startup\*(R" call (say in the constructor
or import) to configure appropriate defaults for the
entire class.
.PP
Note that if install is true for a coderef then 
none of these matter much after the first call
since the installed method will bypass the 
\&\s-1AUTOLOAD\s0.
.PP
Corrilary: If a \*(L"setup\*(R" method is used to set 
metadata values then it probably should not be 
installed so that it can fondle the class' 
metadata and modify it if necewsary on later 
calls.
.PP
This also means that plugin languages should
implement some sort of instructions to modify
the metadata.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "./t/01.t" 4
.IX Item "./t/01.t"
Example plugin class with simple, working
compiler.
.IP "Plugin::Language::DML" 4
.IX Item "Plugin::Language::DML"
Little language for bulk data filtering,
including pre\- and post-processing \s-1DBI\s0 calls;
uses Plugin::Install to handle method installation.
.IP "Symbol" 4
.IX Item "Symbol"
Installing symbols without resoting to no strict 'refs'.
.IP "Scalar::Util" 4
.IX Item "Scalar::Util"
Extracting the basetype of a blessed referent.
.SH "AUTHORS"
.IX Header "AUTHORS"
Steven Lembark  <lembark@wrkhors.com>
Florian Mayr    <florian.mayr@gmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2005 by the authors; this code can 
be reused and re-released under the same terms 
as Perl\-5.8.0 or any later version of the Perl. 
